/****************************************************************************
**
** Copyright (C) 2014 Alexander Rössler
** License: LGPL version 2.1
**
** This file is part of QtQuickVcp.
**
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the GNU Lesser General Public License
** (LGPL) version 2.1 which accompanies this distribution, and is available at
** http://www.gnu.org/licenses/lgpl-2.1.html
**
** This library is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** Lesser General Public License for more details.
**
** Contributors:
** Alexander Rössler @ The Cool Tool GmbH <mail DOT aroessler AT gmail DOT com>
**
****************************************************************************/
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: canon.proto

#ifndef PROTOBUF_canon_2eproto__INCLUDED
#define PROTOBUF_canon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "emcclass.pb.h"
#include "motcmds.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_canon_2eproto();
void protobuf_AssignDesc_canon_2eproto();
void protobuf_ShutdownFile_canon_2eproto();

class Emc_Traj_Set_G5x;
class Emc_Traj_Set_G92;
class Emc_Traj_Set_Rotation;
class Emc_Traj_Linear_Move;
class Emc_Traj_Probe;
class Emc_Traj_Circular_Move;
class Emc_Traj_Rigid_Tap;
class Emc_Traj_Set_Term_Cond;
class Emc_Traj_Set_Spindlesync;
class Emc_Traj_Delay;
class Emc_Spindle_On;
class Emc_Spindle_Speed;
class Emc_Spindle_Orient;
class Emc_Spindle_Wait_Orient_Complete;
class Emc_Tool_Set_Offset;
class Emc_Traj_Set_Offset;
class Emc_Tool_Prepare;
class Emc_Tool_Set_Number;
class Emc_Traj_Set_Fo_Enable;
class Emc_Traj_Set_So_Enable;
class Emc_Traj_Set_Fh_Enable;
class Emc_Motion_Adaptive;
class Emc_Operator_Display;
class Emc_Operator_Text;
class Emc_Operator_Error;
class Emc_Motion_Set_Dout;
class Emc_Motion_Set_Aout;
class Emc_Aux_Input_Wait;
class Emc_Exec_Plugin_Ca1l;
class Emc_Io_Plugin_Call;

// ===================================================================

class Emc_Traj_Set_G5x : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_G5x();
  virtual ~Emc_Traj_Set_G5x();

  Emc_Traj_Set_G5x(const Emc_Traj_Set_G5x& from);

  inline Emc_Traj_Set_G5x& operator=(const Emc_Traj_Set_G5x& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_G5x& default_instance();

  void Swap(Emc_Traj_Set_G5x* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_G5x* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_G5x& from);
  void MergeFrom(const Emc_Traj_Set_G5x& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EmcPose origin = 10;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 10;
  inline const ::pb::EmcPose& origin() const;
  inline ::pb::EmcPose* mutable_origin();
  inline ::pb::EmcPose* release_origin();
  inline void set_allocated_origin(::pb::EmcPose* origin);

  // required .pb.OriginIndex g5x_index = 20;
  inline bool has_g5x_index() const;
  inline void clear_g5x_index();
  static const int kG5XIndexFieldNumber = 20;
  inline ::pb::OriginIndex g5x_index() const;
  inline void set_g5x_index(::pb::OriginIndex value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_G5x)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_g5x_index();
  inline void clear_has_g5x_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* origin_;
  int g5x_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_G5x* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_G92 : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_G92();
  virtual ~Emc_Traj_Set_G92();

  Emc_Traj_Set_G92(const Emc_Traj_Set_G92& from);

  inline Emc_Traj_Set_G92& operator=(const Emc_Traj_Set_G92& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_G92& default_instance();

  void Swap(Emc_Traj_Set_G92* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_G92* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_G92& from);
  void MergeFrom(const Emc_Traj_Set_G92& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EmcPose origin = 10;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 10;
  inline const ::pb::EmcPose& origin() const;
  inline ::pb::EmcPose* mutable_origin();
  inline ::pb::EmcPose* release_origin();
  inline void set_allocated_origin(::pb::EmcPose* origin);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_G92)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* origin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_G92* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Rotation : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Rotation();
  virtual ~Emc_Traj_Set_Rotation();

  Emc_Traj_Set_Rotation(const Emc_Traj_Set_Rotation& from);

  inline Emc_Traj_Set_Rotation& operator=(const Emc_Traj_Set_Rotation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Rotation& default_instance();

  void Swap(Emc_Traj_Set_Rotation* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Rotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Rotation& from);
  void MergeFrom(const Emc_Traj_Set_Rotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double rotation = 10;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 10;
  inline double rotation() const;
  inline void set_rotation(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Rotation)
 private:
  inline void set_has_rotation();
  inline void clear_has_rotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double rotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Rotation* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Linear_Move : public ::google::protobuf::Message {
 public:
  Emc_Traj_Linear_Move();
  virtual ~Emc_Traj_Linear_Move();

  Emc_Traj_Linear_Move(const Emc_Traj_Linear_Move& from);

  inline Emc_Traj_Linear_Move& operator=(const Emc_Traj_Linear_Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Linear_Move& default_instance();

  void Swap(Emc_Traj_Linear_Move* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Linear_Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Linear_Move& from);
  void MergeFrom(const Emc_Traj_Linear_Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.MotionType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::pb::MotionType type() const;
  inline void set_type(::pb::MotionType value);

  // required .pb.EmcPose end = 20;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 20;
  inline const ::pb::EmcPose& end() const;
  inline ::pb::EmcPose* mutable_end();
  inline ::pb::EmcPose* release_end();
  inline void set_allocated_end(::pb::EmcPose* end);

  // required double vel = 30;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 30;
  inline double vel() const;
  inline void set_vel(double value);

  // required double ini_maxvel = 40;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // required double acc = 50;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 50;
  inline double acc() const;
  inline void set_acc(double value);

  // required bool feed_mode = 60;
  inline bool has_feed_mode() const;
  inline void clear_feed_mode();
  static const int kFeedModeFieldNumber = 60;
  inline bool feed_mode() const;
  inline void set_feed_mode(bool value);

  // required int32 indexrotary = 70;
  inline bool has_indexrotary() const;
  inline void clear_indexrotary();
  static const int kIndexrotaryFieldNumber = 70;
  inline ::google::protobuf::int32 indexrotary() const;
  inline void set_indexrotary(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Linear_Move)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_feed_mode();
  inline void clear_has_feed_mode();
  inline void set_has_indexrotary();
  inline void clear_has_indexrotary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* end_;
  double vel_;
  int type_;
  bool feed_mode_;
  double ini_maxvel_;
  double acc_;
  ::google::protobuf::int32 indexrotary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Linear_Move* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Probe : public ::google::protobuf::Message {
 public:
  Emc_Traj_Probe();
  virtual ~Emc_Traj_Probe();

  Emc_Traj_Probe(const Emc_Traj_Probe& from);

  inline Emc_Traj_Probe& operator=(const Emc_Traj_Probe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Probe& default_instance();

  void Swap(Emc_Traj_Probe* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Probe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Probe& from);
  void MergeFrom(const Emc_Traj_Probe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.MotionType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::pb::MotionType type() const;
  inline void set_type(::pb::MotionType value);

  // required .pb.EmcPose pos = 20;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 20;
  inline const ::pb::EmcPose& pos() const;
  inline ::pb::EmcPose* mutable_pos();
  inline ::pb::EmcPose* release_pos();
  inline void set_allocated_pos(::pb::EmcPose* pos);

  // required double vel = 30;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 30;
  inline double vel() const;
  inline void set_vel(double value);

  // required double ini_maxvel = 40;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // required double acc = 50;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 50;
  inline double acc() const;
  inline void set_acc(double value);

  // required uint32 probe_type = 60;
  inline bool has_probe_type() const;
  inline void clear_probe_type();
  static const int kProbeTypeFieldNumber = 60;
  inline ::google::protobuf::uint32 probe_type() const;
  inline void set_probe_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Probe)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_probe_type();
  inline void clear_has_probe_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* pos_;
  double vel_;
  int type_;
  ::google::protobuf::uint32 probe_type_;
  double ini_maxvel_;
  double acc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Probe* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Circular_Move : public ::google::protobuf::Message {
 public:
  Emc_Traj_Circular_Move();
  virtual ~Emc_Traj_Circular_Move();

  Emc_Traj_Circular_Move(const Emc_Traj_Circular_Move& from);

  inline Emc_Traj_Circular_Move& operator=(const Emc_Traj_Circular_Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Circular_Move& default_instance();

  void Swap(Emc_Traj_Circular_Move* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Circular_Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Circular_Move& from);
  void MergeFrom(const Emc_Traj_Circular_Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.MotionType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::pb::MotionType type() const;
  inline void set_type(::pb::MotionType value);

  // required .pb.EmcPose end = 20;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 20;
  inline const ::pb::EmcPose& end() const;
  inline ::pb::EmcPose* mutable_end();
  inline ::pb::EmcPose* release_end();
  inline void set_allocated_end(::pb::EmcPose* end);

  // required .pb.PmCartesian center = 25;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 25;
  inline const ::pb::PmCartesian& center() const;
  inline ::pb::PmCartesian* mutable_center();
  inline ::pb::PmCartesian* release_center();
  inline void set_allocated_center(::pb::PmCartesian* center);

  // required .pb.PmCartesian normal = 27;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 27;
  inline const ::pb::PmCartesian& normal() const;
  inline ::pb::PmCartesian* mutable_normal();
  inline ::pb::PmCartesian* release_normal();
  inline void set_allocated_normal(::pb::PmCartesian* normal);

  // required double vel = 30;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 30;
  inline double vel() const;
  inline void set_vel(double value);

  // required double ini_maxvel = 40;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // required double acc = 50;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 50;
  inline double acc() const;
  inline void set_acc(double value);

  // required bool feed_mode = 60;
  inline bool has_feed_mode() const;
  inline void clear_feed_mode();
  static const int kFeedModeFieldNumber = 60;
  inline bool feed_mode() const;
  inline void set_feed_mode(bool value);

  // required int32 turn = 70;
  inline bool has_turn() const;
  inline void clear_turn();
  static const int kTurnFieldNumber = 70;
  inline ::google::protobuf::int32 turn() const;
  inline void set_turn(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Circular_Move)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_feed_mode();
  inline void clear_has_feed_mode();
  inline void set_has_turn();
  inline void clear_has_turn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* end_;
  ::pb::PmCartesian* center_;
  ::pb::PmCartesian* normal_;
  int type_;
  bool feed_mode_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  ::google::protobuf::int32 turn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Circular_Move* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Rigid_Tap : public ::google::protobuf::Message {
 public:
  Emc_Traj_Rigid_Tap();
  virtual ~Emc_Traj_Rigid_Tap();

  Emc_Traj_Rigid_Tap(const Emc_Traj_Rigid_Tap& from);

  inline Emc_Traj_Rigid_Tap& operator=(const Emc_Traj_Rigid_Tap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Rigid_Tap& default_instance();

  void Swap(Emc_Traj_Rigid_Tap* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Rigid_Tap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Rigid_Tap& from);
  void MergeFrom(const Emc_Traj_Rigid_Tap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EmcPose pos = 20;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 20;
  inline const ::pb::EmcPose& pos() const;
  inline ::pb::EmcPose* mutable_pos();
  inline ::pb::EmcPose* release_pos();
  inline void set_allocated_pos(::pb::EmcPose* pos);

  // required double vel = 30;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 30;
  inline double vel() const;
  inline void set_vel(double value);

  // required double ini_maxvel = 40;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // required double acc = 50;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 50;
  inline double acc() const;
  inline void set_acc(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Rigid_Tap)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_acc();
  inline void clear_has_acc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* pos_;
  double vel_;
  double ini_maxvel_;
  double acc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Rigid_Tap* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Term_Cond : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Term_Cond();
  virtual ~Emc_Traj_Set_Term_Cond();

  Emc_Traj_Set_Term_Cond(const Emc_Traj_Set_Term_Cond& from);

  inline Emc_Traj_Set_Term_Cond& operator=(const Emc_Traj_Set_Term_Cond& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Term_Cond& default_instance();

  void Swap(Emc_Traj_Set_Term_Cond* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Term_Cond* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Term_Cond& from);
  void MergeFrom(const Emc_Traj_Set_Term_Cond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.TermConditionType cond = 10;
  inline bool has_cond() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 10;
  inline ::pb::TermConditionType cond() const;
  inline void set_cond(::pb::TermConditionType value);

  // required double tolerance = 20;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 20;
  inline double tolerance() const;
  inline void set_tolerance(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Term_Cond)
 private:
  inline void set_has_cond();
  inline void clear_has_cond();
  inline void set_has_tolerance();
  inline void clear_has_tolerance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double tolerance_;
  int cond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Term_Cond* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Spindlesync : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Spindlesync();
  virtual ~Emc_Traj_Set_Spindlesync();

  Emc_Traj_Set_Spindlesync(const Emc_Traj_Set_Spindlesync& from);

  inline Emc_Traj_Set_Spindlesync& operator=(const Emc_Traj_Set_Spindlesync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Spindlesync& default_instance();

  void Swap(Emc_Traj_Set_Spindlesync* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Spindlesync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Spindlesync& from);
  void MergeFrom(const Emc_Traj_Set_Spindlesync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double feed_per_revolution = 10;
  inline bool has_feed_per_revolution() const;
  inline void clear_feed_per_revolution();
  static const int kFeedPerRevolutionFieldNumber = 10;
  inline double feed_per_revolution() const;
  inline void set_feed_per_revolution(double value);

  // required bool velocity_mode = 20;
  inline bool has_velocity_mode() const;
  inline void clear_velocity_mode();
  static const int kVelocityModeFieldNumber = 20;
  inline bool velocity_mode() const;
  inline void set_velocity_mode(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Spindlesync)
 private:
  inline void set_has_feed_per_revolution();
  inline void clear_has_feed_per_revolution();
  inline void set_has_velocity_mode();
  inline void clear_has_velocity_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double feed_per_revolution_;
  bool velocity_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Spindlesync* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Delay : public ::google::protobuf::Message {
 public:
  Emc_Traj_Delay();
  virtual ~Emc_Traj_Delay();

  Emc_Traj_Delay(const Emc_Traj_Delay& from);

  inline Emc_Traj_Delay& operator=(const Emc_Traj_Delay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Delay& default_instance();

  void Swap(Emc_Traj_Delay* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Delay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Delay& from);
  void MergeFrom(const Emc_Traj_Delay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double delay = 10;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 10;
  inline double delay() const;
  inline void set_delay(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Delay)
 private:
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double delay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Delay* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Spindle_On : public ::google::protobuf::Message {
 public:
  Emc_Spindle_On();
  virtual ~Emc_Spindle_On();

  Emc_Spindle_On(const Emc_Spindle_On& from);

  inline Emc_Spindle_On& operator=(const Emc_Spindle_On& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_On& default_instance();

  void Swap(Emc_Spindle_On* other);

  // implements Message ----------------------------------------------

  Emc_Spindle_On* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Spindle_On& from);
  void MergeFrom(const Emc_Spindle_On& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double speed = 10 [default = 0];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 10;
  inline double speed() const;
  inline void set_speed(double value);

  // required double factor = 20 [default = 0];
  inline bool has_factor() const;
  inline void clear_factor();
  static const int kFactorFieldNumber = 20;
  inline double factor() const;
  inline void set_factor(double value);

  // required double xoffset = 30 [default = 0];
  inline bool has_xoffset() const;
  inline void clear_xoffset();
  static const int kXoffsetFieldNumber = 30;
  inline double xoffset() const;
  inline void set_xoffset(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Spindle_On)
 private:
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_factor();
  inline void clear_has_factor();
  inline void set_has_xoffset();
  inline void clear_has_xoffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double speed_;
  double factor_;
  double xoffset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Spindle_On* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Spindle_Speed : public ::google::protobuf::Message {
 public:
  Emc_Spindle_Speed();
  virtual ~Emc_Spindle_Speed();

  Emc_Spindle_Speed(const Emc_Spindle_Speed& from);

  inline Emc_Spindle_Speed& operator=(const Emc_Spindle_Speed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Speed& default_instance();

  void Swap(Emc_Spindle_Speed* other);

  // implements Message ----------------------------------------------

  Emc_Spindle_Speed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Spindle_Speed& from);
  void MergeFrom(const Emc_Spindle_Speed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double speed = 10;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 10;
  inline double speed() const;
  inline void set_speed(double value);

  // required double factor = 20;
  inline bool has_factor() const;
  inline void clear_factor();
  static const int kFactorFieldNumber = 20;
  inline double factor() const;
  inline void set_factor(double value);

  // required double xoffset = 30;
  inline bool has_xoffset() const;
  inline void clear_xoffset();
  static const int kXoffsetFieldNumber = 30;
  inline double xoffset() const;
  inline void set_xoffset(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Spindle_Speed)
 private:
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_factor();
  inline void clear_has_factor();
  inline void set_has_xoffset();
  inline void clear_has_xoffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double speed_;
  double factor_;
  double xoffset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Spindle_Speed* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Spindle_Orient : public ::google::protobuf::Message {
 public:
  Emc_Spindle_Orient();
  virtual ~Emc_Spindle_Orient();

  Emc_Spindle_Orient(const Emc_Spindle_Orient& from);

  inline Emc_Spindle_Orient& operator=(const Emc_Spindle_Orient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Orient& default_instance();

  void Swap(Emc_Spindle_Orient* other);

  // implements Message ----------------------------------------------

  Emc_Spindle_Orient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Spindle_Orient& from);
  void MergeFrom(const Emc_Spindle_Orient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double orientation = 10;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 10;
  inline double orientation() const;
  inline void set_orientation(double value);

  // required .pb.CanonDirection mode = 20;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 20;
  inline ::pb::CanonDirection mode() const;
  inline void set_mode(::pb::CanonDirection value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Spindle_Orient)
 private:
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double orientation_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Spindle_Orient* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Spindle_Wait_Orient_Complete : public ::google::protobuf::Message {
 public:
  Emc_Spindle_Wait_Orient_Complete();
  virtual ~Emc_Spindle_Wait_Orient_Complete();

  Emc_Spindle_Wait_Orient_Complete(const Emc_Spindle_Wait_Orient_Complete& from);

  inline Emc_Spindle_Wait_Orient_Complete& operator=(const Emc_Spindle_Wait_Orient_Complete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Wait_Orient_Complete& default_instance();

  void Swap(Emc_Spindle_Wait_Orient_Complete* other);

  // implements Message ----------------------------------------------

  Emc_Spindle_Wait_Orient_Complete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Spindle_Wait_Orient_Complete& from);
  void MergeFrom(const Emc_Spindle_Wait_Orient_Complete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline double timeout() const;
  inline void set_timeout(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Spindle_Wait_Orient_Complete)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Spindle_Wait_Orient_Complete* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Tool_Set_Offset : public ::google::protobuf::Message {
 public:
  Emc_Tool_Set_Offset();
  virtual ~Emc_Tool_Set_Offset();

  Emc_Tool_Set_Offset(const Emc_Tool_Set_Offset& from);

  inline Emc_Tool_Set_Offset& operator=(const Emc_Tool_Set_Offset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Set_Offset& default_instance();

  void Swap(Emc_Tool_Set_Offset* other);

  // implements Message ----------------------------------------------

  Emc_Tool_Set_Offset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Tool_Set_Offset& from);
  void MergeFrom(const Emc_Tool_Set_Offset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pocket = 10;
  inline bool has_pocket() const;
  inline void clear_pocket();
  static const int kPocketFieldNumber = 10;
  inline ::google::protobuf::int32 pocket() const;
  inline void set_pocket(::google::protobuf::int32 value);

  // required int32 toolno = 15;
  inline bool has_toolno() const;
  inline void clear_toolno();
  static const int kToolnoFieldNumber = 15;
  inline ::google::protobuf::int32 toolno() const;
  inline void set_toolno(::google::protobuf::int32 value);

  // required .pb.EmcPose offset = 20;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 20;
  inline const ::pb::EmcPose& offset() const;
  inline ::pb::EmcPose* mutable_offset();
  inline ::pb::EmcPose* release_offset();
  inline void set_allocated_offset(::pb::EmcPose* offset);

  // required double diameter = 30;
  inline bool has_diameter() const;
  inline void clear_diameter();
  static const int kDiameterFieldNumber = 30;
  inline double diameter() const;
  inline void set_diameter(double value);

  // required double frontangle = 40;
  inline bool has_frontangle() const;
  inline void clear_frontangle();
  static const int kFrontangleFieldNumber = 40;
  inline double frontangle() const;
  inline void set_frontangle(double value);

  // required double backangle = 50;
  inline bool has_backangle() const;
  inline void clear_backangle();
  static const int kBackangleFieldNumber = 50;
  inline double backangle() const;
  inline void set_backangle(double value);

  // required int32 orientation = 60;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 60;
  inline ::google::protobuf::int32 orientation() const;
  inline void set_orientation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Tool_Set_Offset)
 private:
  inline void set_has_pocket();
  inline void clear_has_pocket();
  inline void set_has_toolno();
  inline void clear_has_toolno();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_diameter();
  inline void clear_has_diameter();
  inline void set_has_frontangle();
  inline void clear_has_frontangle();
  inline void set_has_backangle();
  inline void clear_has_backangle();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pocket_;
  ::google::protobuf::int32 toolno_;
  ::pb::EmcPose* offset_;
  double diameter_;
  double frontangle_;
  double backangle_;
  ::google::protobuf::int32 orientation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Tool_Set_Offset* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Offset : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Offset();
  virtual ~Emc_Traj_Set_Offset();

  Emc_Traj_Set_Offset(const Emc_Traj_Set_Offset& from);

  inline Emc_Traj_Set_Offset& operator=(const Emc_Traj_Set_Offset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Offset& default_instance();

  void Swap(Emc_Traj_Set_Offset* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Offset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Offset& from);
  void MergeFrom(const Emc_Traj_Set_Offset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.EmcPose offset = 10;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 10;
  inline const ::pb::EmcPose& offset() const;
  inline ::pb::EmcPose* mutable_offset();
  inline ::pb::EmcPose* release_offset();
  inline void set_allocated_offset(::pb::EmcPose* offset);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Offset)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::EmcPose* offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Offset* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Tool_Prepare : public ::google::protobuf::Message {
 public:
  Emc_Tool_Prepare();
  virtual ~Emc_Tool_Prepare();

  Emc_Tool_Prepare(const Emc_Tool_Prepare& from);

  inline Emc_Tool_Prepare& operator=(const Emc_Tool_Prepare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Prepare& default_instance();

  void Swap(Emc_Tool_Prepare* other);

  // implements Message ----------------------------------------------

  Emc_Tool_Prepare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Tool_Prepare& from);
  void MergeFrom(const Emc_Tool_Prepare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pocket = 10;
  inline bool has_pocket() const;
  inline void clear_pocket();
  static const int kPocketFieldNumber = 10;
  inline ::google::protobuf::int32 pocket() const;
  inline void set_pocket(::google::protobuf::int32 value);

  // required int32 tool = 20;
  inline bool has_tool() const;
  inline void clear_tool();
  static const int kToolFieldNumber = 20;
  inline ::google::protobuf::int32 tool() const;
  inline void set_tool(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Tool_Prepare)
 private:
  inline void set_has_pocket();
  inline void clear_has_pocket();
  inline void set_has_tool();
  inline void clear_has_tool();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pocket_;
  ::google::protobuf::int32 tool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Tool_Prepare* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Tool_Set_Number : public ::google::protobuf::Message {
 public:
  Emc_Tool_Set_Number();
  virtual ~Emc_Tool_Set_Number();

  Emc_Tool_Set_Number(const Emc_Tool_Set_Number& from);

  inline Emc_Tool_Set_Number& operator=(const Emc_Tool_Set_Number& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Set_Number& default_instance();

  void Swap(Emc_Tool_Set_Number* other);

  // implements Message ----------------------------------------------

  Emc_Tool_Set_Number* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Tool_Set_Number& from);
  void MergeFrom(const Emc_Tool_Set_Number& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tool = 10;
  inline bool has_tool() const;
  inline void clear_tool();
  static const int kToolFieldNumber = 10;
  inline ::google::protobuf::int32 tool() const;
  inline void set_tool(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Tool_Set_Number)
 private:
  inline void set_has_tool();
  inline void clear_has_tool();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Tool_Set_Number* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Fo_Enable : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Fo_Enable();
  virtual ~Emc_Traj_Set_Fo_Enable();

  Emc_Traj_Set_Fo_Enable(const Emc_Traj_Set_Fo_Enable& from);

  inline Emc_Traj_Set_Fo_Enable& operator=(const Emc_Traj_Set_Fo_Enable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Fo_Enable& default_instance();

  void Swap(Emc_Traj_Set_Fo_Enable* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Fo_Enable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Fo_Enable& from);
  void MergeFrom(const Emc_Traj_Set_Fo_Enable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 10;
  inline bool mode() const;
  inline void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Fo_Enable)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Fo_Enable* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_So_Enable : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_So_Enable();
  virtual ~Emc_Traj_Set_So_Enable();

  Emc_Traj_Set_So_Enable(const Emc_Traj_Set_So_Enable& from);

  inline Emc_Traj_Set_So_Enable& operator=(const Emc_Traj_Set_So_Enable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_So_Enable& default_instance();

  void Swap(Emc_Traj_Set_So_Enable* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_So_Enable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_So_Enable& from);
  void MergeFrom(const Emc_Traj_Set_So_Enable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 10;
  inline bool mode() const;
  inline void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_So_Enable)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_So_Enable* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Fh_Enable : public ::google::protobuf::Message {
 public:
  Emc_Traj_Set_Fh_Enable();
  virtual ~Emc_Traj_Set_Fh_Enable();

  Emc_Traj_Set_Fh_Enable(const Emc_Traj_Set_Fh_Enable& from);

  inline Emc_Traj_Set_Fh_Enable& operator=(const Emc_Traj_Set_Fh_Enable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Fh_Enable& default_instance();

  void Swap(Emc_Traj_Set_Fh_Enable* other);

  // implements Message ----------------------------------------------

  Emc_Traj_Set_Fh_Enable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Traj_Set_Fh_Enable& from);
  void MergeFrom(const Emc_Traj_Set_Fh_Enable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 10;
  inline bool mode() const;
  inline void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Traj_Set_Fh_Enable)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Traj_Set_Fh_Enable* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Motion_Adaptive : public ::google::protobuf::Message {
 public:
  Emc_Motion_Adaptive();
  virtual ~Emc_Motion_Adaptive();

  Emc_Motion_Adaptive(const Emc_Motion_Adaptive& from);

  inline Emc_Motion_Adaptive& operator=(const Emc_Motion_Adaptive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Adaptive& default_instance();

  void Swap(Emc_Motion_Adaptive* other);

  // implements Message ----------------------------------------------

  Emc_Motion_Adaptive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Motion_Adaptive& from);
  void MergeFrom(const Emc_Motion_Adaptive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline bool status() const;
  inline void set_status(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Motion_Adaptive)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Motion_Adaptive* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Operator_Display : public ::google::protobuf::Message {
 public:
  Emc_Operator_Display();
  virtual ~Emc_Operator_Display();

  Emc_Operator_Display(const Emc_Operator_Display& from);

  inline Emc_Operator_Display& operator=(const Emc_Operator_Display& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Display& default_instance();

  void Swap(Emc_Operator_Display* other);

  // implements Message ----------------------------------------------

  Emc_Operator_Display* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Operator_Display& from);
  void MergeFrom(const Emc_Operator_Display& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 10;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 10;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string display = 20;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 20;
  inline const ::std::string& display() const;
  inline void set_display(const ::std::string& value);
  inline void set_display(const char* value);
  inline void set_display(const char* value, size_t size);
  inline ::std::string* mutable_display();
  inline ::std::string* release_display();
  inline void set_allocated_display(::std::string* display);

  // @@protoc_insertion_point(class_scope:pb.Emc_Operator_Display)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_display();
  inline void clear_has_display();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* display_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Operator_Display* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Operator_Text : public ::google::protobuf::Message {
 public:
  Emc_Operator_Text();
  virtual ~Emc_Operator_Text();

  Emc_Operator_Text(const Emc_Operator_Text& from);

  inline Emc_Operator_Text& operator=(const Emc_Operator_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Text& default_instance();

  void Swap(Emc_Operator_Text* other);

  // implements Message ----------------------------------------------

  Emc_Operator_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Operator_Text& from);
  void MergeFrom(const Emc_Operator_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 10;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 10;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string text = 20;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 20;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:pb.Emc_Operator_Text)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Operator_Text* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Operator_Error : public ::google::protobuf::Message {
 public:
  Emc_Operator_Error();
  virtual ~Emc_Operator_Error();

  Emc_Operator_Error(const Emc_Operator_Error& from);

  inline Emc_Operator_Error& operator=(const Emc_Operator_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Error& default_instance();

  void Swap(Emc_Operator_Error* other);

  // implements Message ----------------------------------------------

  Emc_Operator_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Operator_Error& from);
  void MergeFrom(const Emc_Operator_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 10;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 10;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string error = 20;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 20;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:pb.Emc_Operator_Error)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Operator_Error* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Motion_Set_Dout : public ::google::protobuf::Message {
 public:
  Emc_Motion_Set_Dout();
  virtual ~Emc_Motion_Set_Dout();

  Emc_Motion_Set_Dout(const Emc_Motion_Set_Dout& from);

  inline Emc_Motion_Set_Dout& operator=(const Emc_Motion_Set_Dout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Set_Dout& default_instance();

  void Swap(Emc_Motion_Set_Dout* other);

  // implements Message ----------------------------------------------

  Emc_Motion_Set_Dout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Motion_Set_Dout& from);
  void MergeFrom(const Emc_Motion_Set_Dout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 10;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required bool start = 20;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 20;
  inline bool start() const;
  inline void set_start(bool value);

  // required bool end = 30;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 30;
  inline bool end() const;
  inline void set_end(bool value);

  // required bool now = 40;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 40;
  inline bool now() const;
  inline void set_now(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Motion_Set_Dout)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_now();
  inline void clear_has_now();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  bool start_;
  bool end_;
  bool now_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Motion_Set_Dout* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Motion_Set_Aout : public ::google::protobuf::Message {
 public:
  Emc_Motion_Set_Aout();
  virtual ~Emc_Motion_Set_Aout();

  Emc_Motion_Set_Aout(const Emc_Motion_Set_Aout& from);

  inline Emc_Motion_Set_Aout& operator=(const Emc_Motion_Set_Aout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Set_Aout& default_instance();

  void Swap(Emc_Motion_Set_Aout* other);

  // implements Message ----------------------------------------------

  Emc_Motion_Set_Aout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Motion_Set_Aout& from);
  void MergeFrom(const Emc_Motion_Set_Aout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 10;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required double start = 20;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 20;
  inline double start() const;
  inline void set_start(double value);

  // required double end = 30;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 30;
  inline double end() const;
  inline void set_end(double value);

  // required bool now = 40;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 40;
  inline bool now() const;
  inline void set_now(bool value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Motion_Set_Aout)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_now();
  inline void clear_has_now();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double start_;
  ::google::protobuf::uint32 index_;
  bool now_;
  double end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Motion_Set_Aout* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Aux_Input_Wait : public ::google::protobuf::Message {
 public:
  Emc_Aux_Input_Wait();
  virtual ~Emc_Aux_Input_Wait();

  Emc_Aux_Input_Wait(const Emc_Aux_Input_Wait& from);

  inline Emc_Aux_Input_Wait& operator=(const Emc_Aux_Input_Wait& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Aux_Input_Wait& default_instance();

  void Swap(Emc_Aux_Input_Wait* other);

  // implements Message ----------------------------------------------

  Emc_Aux_Input_Wait* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Aux_Input_Wait& from);
  void MergeFrom(const Emc_Aux_Input_Wait& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 10;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required .pb.InputType input_type = 20;
  inline bool has_input_type() const;
  inline void clear_input_type();
  static const int kInputTypeFieldNumber = 20;
  inline ::pb::InputType input_type() const;
  inline void set_input_type(::pb::InputType value);

  // required .pb.WaitType wait_type = 30;
  inline bool has_wait_type() const;
  inline void clear_wait_type();
  static const int kWaitTypeFieldNumber = 30;
  inline ::pb::WaitType wait_type() const;
  inline void set_wait_type(::pb::WaitType value);

  // required double timeout = 40;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 40;
  inline double timeout() const;
  inline void set_timeout(double value);

  // @@protoc_insertion_point(class_scope:pb.Emc_Aux_Input_Wait)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_input_type();
  inline void clear_has_input_type();
  inline void set_has_wait_type();
  inline void clear_has_wait_type();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  int input_type_;
  double timeout_;
  int wait_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Aux_Input_Wait* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Exec_Plugin_Ca1l : public ::google::protobuf::Message {
 public:
  Emc_Exec_Plugin_Ca1l();
  virtual ~Emc_Exec_Plugin_Ca1l();

  Emc_Exec_Plugin_Ca1l(const Emc_Exec_Plugin_Ca1l& from);

  inline Emc_Exec_Plugin_Ca1l& operator=(const Emc_Exec_Plugin_Ca1l& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Exec_Plugin_Ca1l& default_instance();

  void Swap(Emc_Exec_Plugin_Ca1l* other);

  // implements Message ----------------------------------------------

  Emc_Exec_Plugin_Ca1l* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Exec_Plugin_Ca1l& from);
  void MergeFrom(const Emc_Exec_Plugin_Ca1l& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes call = 20;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 20;
  inline const ::std::string& call() const;
  inline void set_call(const ::std::string& value);
  inline void set_call(const char* value);
  inline void set_call(const void* value, size_t size);
  inline ::std::string* mutable_call();
  inline ::std::string* release_call();
  inline void set_allocated_call(::std::string* call);

  // @@protoc_insertion_point(class_scope:pb.Emc_Exec_Plugin_Ca1l)
 private:
  inline void set_has_call();
  inline void clear_has_call();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* call_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Exec_Plugin_Ca1l* default_instance_;
};
// -------------------------------------------------------------------

class Emc_Io_Plugin_Call : public ::google::protobuf::Message {
 public:
  Emc_Io_Plugin_Call();
  virtual ~Emc_Io_Plugin_Call();

  Emc_Io_Plugin_Call(const Emc_Io_Plugin_Call& from);

  inline Emc_Io_Plugin_Call& operator=(const Emc_Io_Plugin_Call& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Io_Plugin_Call& default_instance();

  void Swap(Emc_Io_Plugin_Call* other);

  // implements Message ----------------------------------------------

  Emc_Io_Plugin_Call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Emc_Io_Plugin_Call& from);
  void MergeFrom(const Emc_Io_Plugin_Call& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes call = 20;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 20;
  inline const ::std::string& call() const;
  inline void set_call(const ::std::string& value);
  inline void set_call(const char* value);
  inline void set_call(const void* value, size_t size);
  inline ::std::string* mutable_call();
  inline ::std::string* release_call();
  inline void set_allocated_call(::std::string* call);

  // @@protoc_insertion_point(class_scope:pb.Emc_Io_Plugin_Call)
 private:
  inline void set_has_call();
  inline void clear_has_call();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* call_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_canon_2eproto();
  friend void protobuf_AssignDesc_canon_2eproto();
  friend void protobuf_ShutdownFile_canon_2eproto();

  void InitAsDefaultInstance();
  static Emc_Io_Plugin_Call* default_instance_;
};
// ===================================================================


// ===================================================================

// Emc_Traj_Set_G5x

// required .pb.EmcPose origin = 10;
inline bool Emc_Traj_Set_G5x::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_G5x::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_G5x::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_G5x::clear_origin() {
  if (origin_ != NULL) origin_->::pb::EmcPose::Clear();
  clear_has_origin();
}
inline const ::pb::EmcPose& Emc_Traj_Set_G5x::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::pb::EmcPose* Emc_Traj_Set_G5x::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::pb::EmcPose;
  return origin_;
}
inline ::pb::EmcPose* Emc_Traj_Set_G5x::release_origin() {
  clear_has_origin();
  ::pb::EmcPose* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Emc_Traj_Set_G5x::set_allocated_origin(::pb::EmcPose* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// required .pb.OriginIndex g5x_index = 20;
inline bool Emc_Traj_Set_G5x::has_g5x_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_G5x::set_has_g5x_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_G5x::clear_has_g5x_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_G5x::clear_g5x_index() {
  g5x_index_ = 1;
  clear_has_g5x_index();
}
inline ::pb::OriginIndex Emc_Traj_Set_G5x::g5x_index() const {
  return static_cast< ::pb::OriginIndex >(g5x_index_);
}
inline void Emc_Traj_Set_G5x::set_g5x_index(::pb::OriginIndex value) {
  assert(::pb::OriginIndex_IsValid(value));
  set_has_g5x_index();
  g5x_index_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_G92

// required .pb.EmcPose origin = 10;
inline bool Emc_Traj_Set_G92::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_G92::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_G92::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_G92::clear_origin() {
  if (origin_ != NULL) origin_->::pb::EmcPose::Clear();
  clear_has_origin();
}
inline const ::pb::EmcPose& Emc_Traj_Set_G92::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::pb::EmcPose* Emc_Traj_Set_G92::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::pb::EmcPose;
  return origin_;
}
inline ::pb::EmcPose* Emc_Traj_Set_G92::release_origin() {
  clear_has_origin();
  ::pb::EmcPose* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Emc_Traj_Set_G92::set_allocated_origin(::pb::EmcPose* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Rotation

// required double rotation = 10;
inline bool Emc_Traj_Set_Rotation::has_rotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Rotation::set_has_rotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Rotation::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Rotation::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline double Emc_Traj_Set_Rotation::rotation() const {
  return rotation_;
}
inline void Emc_Traj_Set_Rotation::set_rotation(double value) {
  set_has_rotation();
  rotation_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Linear_Move

// required .pb.MotionType type = 10;
inline bool Emc_Traj_Linear_Move::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Linear_Move::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Linear_Move::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::MotionType Emc_Traj_Linear_Move::type() const {
  return static_cast< ::pb::MotionType >(type_);
}
inline void Emc_Traj_Linear_Move::set_type(::pb::MotionType value) {
  assert(::pb::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .pb.EmcPose end = 20;
inline bool Emc_Traj_Linear_Move::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Linear_Move::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Linear_Move::clear_end() {
  if (end_ != NULL) end_->::pb::EmcPose::Clear();
  clear_has_end();
}
inline const ::pb::EmcPose& Emc_Traj_Linear_Move::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::pb::EmcPose* Emc_Traj_Linear_Move::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::pb::EmcPose;
  return end_;
}
inline ::pb::EmcPose* Emc_Traj_Linear_Move::release_end() {
  clear_has_end();
  ::pb::EmcPose* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Emc_Traj_Linear_Move::set_allocated_end(::pb::EmcPose* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// required double vel = 30;
inline bool Emc_Traj_Linear_Move::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Linear_Move::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Linear_Move::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Linear_Move::vel() const {
  return vel_;
}
inline void Emc_Traj_Linear_Move::set_vel(double value) {
  set_has_vel();
  vel_ = value;
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Linear_Move::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Linear_Move::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Linear_Move::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Linear_Move::ini_maxvel() const {
  return ini_maxvel_;
}
inline void Emc_Traj_Linear_Move::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
}

// required double acc = 50;
inline bool Emc_Traj_Linear_Move::has_acc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_acc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Linear_Move::clear_has_acc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Linear_Move::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Linear_Move::acc() const {
  return acc_;
}
inline void Emc_Traj_Linear_Move::set_acc(double value) {
  set_has_acc();
  acc_ = value;
}

// required bool feed_mode = 60;
inline bool Emc_Traj_Linear_Move::has_feed_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_feed_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Linear_Move::clear_has_feed_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Linear_Move::clear_feed_mode() {
  feed_mode_ = false;
  clear_has_feed_mode();
}
inline bool Emc_Traj_Linear_Move::feed_mode() const {
  return feed_mode_;
}
inline void Emc_Traj_Linear_Move::set_feed_mode(bool value) {
  set_has_feed_mode();
  feed_mode_ = value;
}

// required int32 indexrotary = 70;
inline bool Emc_Traj_Linear_Move::has_indexrotary() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_indexrotary() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Traj_Linear_Move::clear_has_indexrotary() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Traj_Linear_Move::clear_indexrotary() {
  indexrotary_ = 0;
  clear_has_indexrotary();
}
inline ::google::protobuf::int32 Emc_Traj_Linear_Move::indexrotary() const {
  return indexrotary_;
}
inline void Emc_Traj_Linear_Move::set_indexrotary(::google::protobuf::int32 value) {
  set_has_indexrotary();
  indexrotary_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Probe

// required .pb.MotionType type = 10;
inline bool Emc_Traj_Probe::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Probe::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Probe::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Probe::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::MotionType Emc_Traj_Probe::type() const {
  return static_cast< ::pb::MotionType >(type_);
}
inline void Emc_Traj_Probe::set_type(::pb::MotionType value) {
  assert(::pb::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .pb.EmcPose pos = 20;
inline bool Emc_Traj_Probe::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Probe::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Probe::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Probe::clear_pos() {
  if (pos_ != NULL) pos_->::pb::EmcPose::Clear();
  clear_has_pos();
}
inline const ::pb::EmcPose& Emc_Traj_Probe::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::pb::EmcPose* Emc_Traj_Probe::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::pb::EmcPose;
  return pos_;
}
inline ::pb::EmcPose* Emc_Traj_Probe::release_pos() {
  clear_has_pos();
  ::pb::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Emc_Traj_Probe::set_allocated_pos(::pb::EmcPose* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required double vel = 30;
inline bool Emc_Traj_Probe::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Probe::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Probe::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Probe::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Probe::vel() const {
  return vel_;
}
inline void Emc_Traj_Probe::set_vel(double value) {
  set_has_vel();
  vel_ = value;
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Probe::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Probe::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Probe::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Probe::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Probe::ini_maxvel() const {
  return ini_maxvel_;
}
inline void Emc_Traj_Probe::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
}

// required double acc = 50;
inline bool Emc_Traj_Probe::has_acc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Probe::set_has_acc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Probe::clear_has_acc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Probe::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Probe::acc() const {
  return acc_;
}
inline void Emc_Traj_Probe::set_acc(double value) {
  set_has_acc();
  acc_ = value;
}

// required uint32 probe_type = 60;
inline bool Emc_Traj_Probe::has_probe_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Probe::set_has_probe_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Probe::clear_has_probe_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Probe::clear_probe_type() {
  probe_type_ = 0u;
  clear_has_probe_type();
}
inline ::google::protobuf::uint32 Emc_Traj_Probe::probe_type() const {
  return probe_type_;
}
inline void Emc_Traj_Probe::set_probe_type(::google::protobuf::uint32 value) {
  set_has_probe_type();
  probe_type_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Circular_Move

// required .pb.MotionType type = 10;
inline bool Emc_Traj_Circular_Move::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Circular_Move::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Circular_Move::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::MotionType Emc_Traj_Circular_Move::type() const {
  return static_cast< ::pb::MotionType >(type_);
}
inline void Emc_Traj_Circular_Move::set_type(::pb::MotionType value) {
  assert(::pb::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .pb.EmcPose end = 20;
inline bool Emc_Traj_Circular_Move::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Circular_Move::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Circular_Move::clear_end() {
  if (end_ != NULL) end_->::pb::EmcPose::Clear();
  clear_has_end();
}
inline const ::pb::EmcPose& Emc_Traj_Circular_Move::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::pb::EmcPose* Emc_Traj_Circular_Move::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::pb::EmcPose;
  return end_;
}
inline ::pb::EmcPose* Emc_Traj_Circular_Move::release_end() {
  clear_has_end();
  ::pb::EmcPose* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Emc_Traj_Circular_Move::set_allocated_end(::pb::EmcPose* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// required .pb.PmCartesian center = 25;
inline bool Emc_Traj_Circular_Move::has_center() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_center() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Circular_Move::clear_has_center() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Circular_Move::clear_center() {
  if (center_ != NULL) center_->::pb::PmCartesian::Clear();
  clear_has_center();
}
inline const ::pb::PmCartesian& Emc_Traj_Circular_Move::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::pb::PmCartesian* Emc_Traj_Circular_Move::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::pb::PmCartesian;
  return center_;
}
inline ::pb::PmCartesian* Emc_Traj_Circular_Move::release_center() {
  clear_has_center();
  ::pb::PmCartesian* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Emc_Traj_Circular_Move::set_allocated_center(::pb::PmCartesian* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// required .pb.PmCartesian normal = 27;
inline bool Emc_Traj_Circular_Move::has_normal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_normal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Circular_Move::clear_has_normal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Circular_Move::clear_normal() {
  if (normal_ != NULL) normal_->::pb::PmCartesian::Clear();
  clear_has_normal();
}
inline const ::pb::PmCartesian& Emc_Traj_Circular_Move::normal() const {
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::pb::PmCartesian* Emc_Traj_Circular_Move::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::pb::PmCartesian;
  return normal_;
}
inline ::pb::PmCartesian* Emc_Traj_Circular_Move::release_normal() {
  clear_has_normal();
  ::pb::PmCartesian* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Emc_Traj_Circular_Move::set_allocated_normal(::pb::PmCartesian* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
}

// required double vel = 30;
inline bool Emc_Traj_Circular_Move::has_vel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_vel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Circular_Move::clear_has_vel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Circular_Move::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Circular_Move::vel() const {
  return vel_;
}
inline void Emc_Traj_Circular_Move::set_vel(double value) {
  set_has_vel();
  vel_ = value;
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Circular_Move::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Circular_Move::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Circular_Move::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Circular_Move::ini_maxvel() const {
  return ini_maxvel_;
}
inline void Emc_Traj_Circular_Move::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
}

// required double acc = 50;
inline bool Emc_Traj_Circular_Move::has_acc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_acc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Traj_Circular_Move::clear_has_acc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Traj_Circular_Move::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Circular_Move::acc() const {
  return acc_;
}
inline void Emc_Traj_Circular_Move::set_acc(double value) {
  set_has_acc();
  acc_ = value;
}

// required bool feed_mode = 60;
inline bool Emc_Traj_Circular_Move::has_feed_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_feed_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Emc_Traj_Circular_Move::clear_has_feed_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Emc_Traj_Circular_Move::clear_feed_mode() {
  feed_mode_ = false;
  clear_has_feed_mode();
}
inline bool Emc_Traj_Circular_Move::feed_mode() const {
  return feed_mode_;
}
inline void Emc_Traj_Circular_Move::set_feed_mode(bool value) {
  set_has_feed_mode();
  feed_mode_ = value;
}

// required int32 turn = 70;
inline bool Emc_Traj_Circular_Move::has_turn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_turn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Emc_Traj_Circular_Move::clear_has_turn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Emc_Traj_Circular_Move::clear_turn() {
  turn_ = 0;
  clear_has_turn();
}
inline ::google::protobuf::int32 Emc_Traj_Circular_Move::turn() const {
  return turn_;
}
inline void Emc_Traj_Circular_Move::set_turn(::google::protobuf::int32 value) {
  set_has_turn();
  turn_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Rigid_Tap

// required .pb.EmcPose pos = 20;
inline bool Emc_Traj_Rigid_Tap::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Rigid_Tap::clear_pos() {
  if (pos_ != NULL) pos_->::pb::EmcPose::Clear();
  clear_has_pos();
}
inline const ::pb::EmcPose& Emc_Traj_Rigid_Tap::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::pb::EmcPose* Emc_Traj_Rigid_Tap::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::pb::EmcPose;
  return pos_;
}
inline ::pb::EmcPose* Emc_Traj_Rigid_Tap::release_pos() {
  clear_has_pos();
  ::pb::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Emc_Traj_Rigid_Tap::set_allocated_pos(::pb::EmcPose* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required double vel = 30;
inline bool Emc_Traj_Rigid_Tap::has_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_vel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Rigid_Tap::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Rigid_Tap::vel() const {
  return vel_;
}
inline void Emc_Traj_Rigid_Tap::set_vel(double value) {
  set_has_vel();
  vel_ = value;
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Rigid_Tap::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Rigid_Tap::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Rigid_Tap::ini_maxvel() const {
  return ini_maxvel_;
}
inline void Emc_Traj_Rigid_Tap::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
}

// required double acc = 50;
inline bool Emc_Traj_Rigid_Tap::has_acc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_acc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_acc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Rigid_Tap::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Rigid_Tap::acc() const {
  return acc_;
}
inline void Emc_Traj_Rigid_Tap::set_acc(double value) {
  set_has_acc();
  acc_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Term_Cond

// required .pb.TermConditionType cond = 10;
inline bool Emc_Traj_Set_Term_Cond::has_cond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Term_Cond::set_has_cond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Term_Cond::clear_has_cond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Term_Cond::clear_cond() {
  cond_ = 1;
  clear_has_cond();
}
inline ::pb::TermConditionType Emc_Traj_Set_Term_Cond::cond() const {
  return static_cast< ::pb::TermConditionType >(cond_);
}
inline void Emc_Traj_Set_Term_Cond::set_cond(::pb::TermConditionType value) {
  assert(::pb::TermConditionType_IsValid(value));
  set_has_cond();
  cond_ = value;
}

// required double tolerance = 20;
inline bool Emc_Traj_Set_Term_Cond::has_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_Term_Cond::set_has_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_Term_Cond::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_Term_Cond::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double Emc_Traj_Set_Term_Cond::tolerance() const {
  return tolerance_;
}
inline void Emc_Traj_Set_Term_Cond::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Spindlesync

// required double feed_per_revolution = 10;
inline bool Emc_Traj_Set_Spindlesync::has_feed_per_revolution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Spindlesync::set_has_feed_per_revolution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Spindlesync::clear_has_feed_per_revolution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Spindlesync::clear_feed_per_revolution() {
  feed_per_revolution_ = 0;
  clear_has_feed_per_revolution();
}
inline double Emc_Traj_Set_Spindlesync::feed_per_revolution() const {
  return feed_per_revolution_;
}
inline void Emc_Traj_Set_Spindlesync::set_feed_per_revolution(double value) {
  set_has_feed_per_revolution();
  feed_per_revolution_ = value;
}

// required bool velocity_mode = 20;
inline bool Emc_Traj_Set_Spindlesync::has_velocity_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_Spindlesync::set_has_velocity_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_Spindlesync::clear_has_velocity_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_Spindlesync::clear_velocity_mode() {
  velocity_mode_ = false;
  clear_has_velocity_mode();
}
inline bool Emc_Traj_Set_Spindlesync::velocity_mode() const {
  return velocity_mode_;
}
inline void Emc_Traj_Set_Spindlesync::set_velocity_mode(bool value) {
  set_has_velocity_mode();
  velocity_mode_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Delay

// required double delay = 10;
inline bool Emc_Traj_Delay::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Delay::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Delay::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Delay::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double Emc_Traj_Delay::delay() const {
  return delay_;
}
inline void Emc_Traj_Delay::set_delay(double value) {
  set_has_delay();
  delay_ = value;
}

// -------------------------------------------------------------------

// Emc_Spindle_On

// required double speed = 10 [default = 0];
inline bool Emc_Spindle_On::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_On::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_On::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_On::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Emc_Spindle_On::speed() const {
  return speed_;
}
inline void Emc_Spindle_On::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// required double factor = 20 [default = 0];
inline bool Emc_Spindle_On::has_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_On::set_has_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_On::clear_has_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_On::clear_factor() {
  factor_ = 0;
  clear_has_factor();
}
inline double Emc_Spindle_On::factor() const {
  return factor_;
}
inline void Emc_Spindle_On::set_factor(double value) {
  set_has_factor();
  factor_ = value;
}

// required double xoffset = 30 [default = 0];
inline bool Emc_Spindle_On::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Spindle_On::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Spindle_On::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Spindle_On::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline double Emc_Spindle_On::xoffset() const {
  return xoffset_;
}
inline void Emc_Spindle_On::set_xoffset(double value) {
  set_has_xoffset();
  xoffset_ = value;
}

// -------------------------------------------------------------------

// Emc_Spindle_Speed

// required double speed = 10;
inline bool Emc_Spindle_Speed::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Speed::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Speed::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Speed::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Emc_Spindle_Speed::speed() const {
  return speed_;
}
inline void Emc_Spindle_Speed::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// required double factor = 20;
inline bool Emc_Spindle_Speed::has_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_Speed::set_has_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_Speed::clear_has_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_Speed::clear_factor() {
  factor_ = 0;
  clear_has_factor();
}
inline double Emc_Spindle_Speed::factor() const {
  return factor_;
}
inline void Emc_Spindle_Speed::set_factor(double value) {
  set_has_factor();
  factor_ = value;
}

// required double xoffset = 30;
inline bool Emc_Spindle_Speed::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Spindle_Speed::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Spindle_Speed::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Spindle_Speed::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline double Emc_Spindle_Speed::xoffset() const {
  return xoffset_;
}
inline void Emc_Spindle_Speed::set_xoffset(double value) {
  set_has_xoffset();
  xoffset_ = value;
}

// -------------------------------------------------------------------

// Emc_Spindle_Orient

// required double orientation = 10;
inline bool Emc_Spindle_Orient::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Orient::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Orient::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Orient::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double Emc_Spindle_Orient::orientation() const {
  return orientation_;
}
inline void Emc_Spindle_Orient::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
}

// required .pb.CanonDirection mode = 20;
inline bool Emc_Spindle_Orient::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_Orient::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_Orient::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_Orient::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::pb::CanonDirection Emc_Spindle_Orient::mode() const {
  return static_cast< ::pb::CanonDirection >(mode_);
}
inline void Emc_Spindle_Orient::set_mode(::pb::CanonDirection value) {
  assert(::pb::CanonDirection_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// Emc_Spindle_Wait_Orient_Complete

// required double timeout = 10;
inline bool Emc_Spindle_Wait_Orient_Complete::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Wait_Orient_Complete::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Wait_Orient_Complete::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Wait_Orient_Complete::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline double Emc_Spindle_Wait_Orient_Complete::timeout() const {
  return timeout_;
}
inline void Emc_Spindle_Wait_Orient_Complete::set_timeout(double value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Emc_Tool_Set_Offset

// required int32 pocket = 10;
inline bool Emc_Tool_Set_Offset::has_pocket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_pocket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Set_Offset::clear_has_pocket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Tool_Set_Offset::clear_pocket() {
  pocket_ = 0;
  clear_has_pocket();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::pocket() const {
  return pocket_;
}
inline void Emc_Tool_Set_Offset::set_pocket(::google::protobuf::int32 value) {
  set_has_pocket();
  pocket_ = value;
}

// required int32 toolno = 15;
inline bool Emc_Tool_Set_Offset::has_toolno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_toolno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Tool_Set_Offset::clear_has_toolno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Tool_Set_Offset::clear_toolno() {
  toolno_ = 0;
  clear_has_toolno();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::toolno() const {
  return toolno_;
}
inline void Emc_Tool_Set_Offset::set_toolno(::google::protobuf::int32 value) {
  set_has_toolno();
  toolno_ = value;
}

// required .pb.EmcPose offset = 20;
inline bool Emc_Tool_Set_Offset::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Tool_Set_Offset::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Tool_Set_Offset::clear_offset() {
  if (offset_ != NULL) offset_->::pb::EmcPose::Clear();
  clear_has_offset();
}
inline const ::pb::EmcPose& Emc_Tool_Set_Offset::offset() const {
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::pb::EmcPose* Emc_Tool_Set_Offset::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) offset_ = new ::pb::EmcPose;
  return offset_;
}
inline ::pb::EmcPose* Emc_Tool_Set_Offset::release_offset() {
  clear_has_offset();
  ::pb::EmcPose* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void Emc_Tool_Set_Offset::set_allocated_offset(::pb::EmcPose* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    set_has_offset();
  } else {
    clear_has_offset();
  }
}

// required double diameter = 30;
inline bool Emc_Tool_Set_Offset::has_diameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_diameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Tool_Set_Offset::clear_has_diameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Tool_Set_Offset::clear_diameter() {
  diameter_ = 0;
  clear_has_diameter();
}
inline double Emc_Tool_Set_Offset::diameter() const {
  return diameter_;
}
inline void Emc_Tool_Set_Offset::set_diameter(double value) {
  set_has_diameter();
  diameter_ = value;
}

// required double frontangle = 40;
inline bool Emc_Tool_Set_Offset::has_frontangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_frontangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Tool_Set_Offset::clear_has_frontangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Tool_Set_Offset::clear_frontangle() {
  frontangle_ = 0;
  clear_has_frontangle();
}
inline double Emc_Tool_Set_Offset::frontangle() const {
  return frontangle_;
}
inline void Emc_Tool_Set_Offset::set_frontangle(double value) {
  set_has_frontangle();
  frontangle_ = value;
}

// required double backangle = 50;
inline bool Emc_Tool_Set_Offset::has_backangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_backangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Tool_Set_Offset::clear_has_backangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Tool_Set_Offset::clear_backangle() {
  backangle_ = 0;
  clear_has_backangle();
}
inline double Emc_Tool_Set_Offset::backangle() const {
  return backangle_;
}
inline void Emc_Tool_Set_Offset::set_backangle(double value) {
  set_has_backangle();
  backangle_ = value;
}

// required int32 orientation = 60;
inline bool Emc_Tool_Set_Offset::has_orientation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_orientation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Tool_Set_Offset::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Tool_Set_Offset::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::orientation() const {
  return orientation_;
}
inline void Emc_Tool_Set_Offset::set_orientation(::google::protobuf::int32 value) {
  set_has_orientation();
  orientation_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Offset

// required .pb.EmcPose offset = 10;
inline bool Emc_Traj_Set_Offset::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Offset::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Offset::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Offset::clear_offset() {
  if (offset_ != NULL) offset_->::pb::EmcPose::Clear();
  clear_has_offset();
}
inline const ::pb::EmcPose& Emc_Traj_Set_Offset::offset() const {
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::pb::EmcPose* Emc_Traj_Set_Offset::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) offset_ = new ::pb::EmcPose;
  return offset_;
}
inline ::pb::EmcPose* Emc_Traj_Set_Offset::release_offset() {
  clear_has_offset();
  ::pb::EmcPose* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void Emc_Traj_Set_Offset::set_allocated_offset(::pb::EmcPose* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    set_has_offset();
  } else {
    clear_has_offset();
  }
}

// -------------------------------------------------------------------

// Emc_Tool_Prepare

// required int32 pocket = 10;
inline bool Emc_Tool_Prepare::has_pocket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Prepare::set_has_pocket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Prepare::clear_has_pocket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Tool_Prepare::clear_pocket() {
  pocket_ = 0;
  clear_has_pocket();
}
inline ::google::protobuf::int32 Emc_Tool_Prepare::pocket() const {
  return pocket_;
}
inline void Emc_Tool_Prepare::set_pocket(::google::protobuf::int32 value) {
  set_has_pocket();
  pocket_ = value;
}

// required int32 tool = 20;
inline bool Emc_Tool_Prepare::has_tool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Tool_Prepare::set_has_tool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Tool_Prepare::clear_has_tool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Tool_Prepare::clear_tool() {
  tool_ = 0;
  clear_has_tool();
}
inline ::google::protobuf::int32 Emc_Tool_Prepare::tool() const {
  return tool_;
}
inline void Emc_Tool_Prepare::set_tool(::google::protobuf::int32 value) {
  set_has_tool();
  tool_ = value;
}

// -------------------------------------------------------------------

// Emc_Tool_Set_Number

// required int32 tool = 10;
inline bool Emc_Tool_Set_Number::has_tool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Set_Number::set_has_tool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Set_Number::clear_has_tool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Tool_Set_Number::clear_tool() {
  tool_ = 0;
  clear_has_tool();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Number::tool() const {
  return tool_;
}
inline void Emc_Tool_Set_Number::set_tool(::google::protobuf::int32 value) {
  set_has_tool();
  tool_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Fo_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_Fo_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Fo_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Fo_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Fo_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_Fo_Enable::mode() const {
  return mode_;
}
inline void Emc_Traj_Set_Fo_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_So_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_So_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_So_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_So_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_So_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_So_Enable::mode() const {
  return mode_;
}
inline void Emc_Traj_Set_So_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Fh_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_Fh_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Fh_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Fh_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Fh_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_Fh_Enable::mode() const {
  return mode_;
}
inline void Emc_Traj_Set_Fh_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// Emc_Motion_Adaptive

// required bool status = 10;
inline bool Emc_Motion_Adaptive::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Adaptive::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Adaptive::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Adaptive::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool Emc_Motion_Adaptive::status() const {
  return status_;
}
inline void Emc_Motion_Adaptive::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Emc_Operator_Display

// required int32 id = 10;
inline bool Emc_Operator_Display::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Display::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Display::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Display::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Display::id() const {
  return id_;
}
inline void Emc_Operator_Display::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string display = 20;
inline bool Emc_Operator_Display::has_display() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Display::set_has_display() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Display::clear_has_display() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Display::clear_display() {
  if (display_ != &::google::protobuf::internal::GetEmptyString()) {
    display_->clear();
  }
  clear_has_display();
}
inline const ::std::string& Emc_Operator_Display::display() const {
  return *display_;
}
inline void Emc_Operator_Display::set_display(const ::std::string& value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::GetEmptyString()) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void Emc_Operator_Display::set_display(const char* value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::GetEmptyString()) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void Emc_Operator_Display::set_display(const char* value, size_t size) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::GetEmptyString()) {
    display_ = new ::std::string;
  }
  display_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Emc_Operator_Display::mutable_display() {
  set_has_display();
  if (display_ == &::google::protobuf::internal::GetEmptyString()) {
    display_ = new ::std::string;
  }
  return display_;
}
inline ::std::string* Emc_Operator_Display::release_display() {
  clear_has_display();
  if (display_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = display_;
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Emc_Operator_Display::set_allocated_display(::std::string* display) {
  if (display_ != &::google::protobuf::internal::GetEmptyString()) {
    delete display_;
  }
  if (display) {
    set_has_display();
    display_ = display;
  } else {
    clear_has_display();
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Emc_Operator_Text

// required int32 id = 10;
inline bool Emc_Operator_Text::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Text::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Text::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Text::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Text::id() const {
  return id_;
}
inline void Emc_Operator_Text::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string text = 20;
inline bool Emc_Operator_Text::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Text::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Text::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Text::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Emc_Operator_Text::text() const {
  return *text_;
}
inline void Emc_Operator_Text::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Emc_Operator_Text::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Emc_Operator_Text::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Emc_Operator_Text::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Emc_Operator_Text::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Emc_Operator_Text::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Emc_Operator_Error

// required int32 id = 10;
inline bool Emc_Operator_Error::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Error::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Error::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Error::id() const {
  return id_;
}
inline void Emc_Operator_Error::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string error = 20;
inline bool Emc_Operator_Error::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Error::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Error::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Error::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyString()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Emc_Operator_Error::error() const {
  return *error_;
}
inline void Emc_Operator_Error::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyString()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Emc_Operator_Error::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyString()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Emc_Operator_Error::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyString()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Emc_Operator_Error::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyString()) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* Emc_Operator_Error::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Emc_Operator_Error::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyString()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Emc_Motion_Set_Dout

// required uint32 index = 10;
inline bool Emc_Motion_Set_Dout::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Set_Dout::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Set_Dout::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Motion_Set_Dout::index() const {
  return index_;
}
inline void Emc_Motion_Set_Dout::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required bool start = 20;
inline bool Emc_Motion_Set_Dout::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Motion_Set_Dout::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Motion_Set_Dout::clear_start() {
  start_ = false;
  clear_has_start();
}
inline bool Emc_Motion_Set_Dout::start() const {
  return start_;
}
inline void Emc_Motion_Set_Dout::set_start(bool value) {
  set_has_start();
  start_ = value;
}

// required bool end = 30;
inline bool Emc_Motion_Set_Dout::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Motion_Set_Dout::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Motion_Set_Dout::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool Emc_Motion_Set_Dout::end() const {
  return end_;
}
inline void Emc_Motion_Set_Dout::set_end(bool value) {
  set_has_end();
  end_ = value;
}

// required bool now = 40;
inline bool Emc_Motion_Set_Dout::has_now() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_now() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Motion_Set_Dout::clear_has_now() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Motion_Set_Dout::clear_now() {
  now_ = false;
  clear_has_now();
}
inline bool Emc_Motion_Set_Dout::now() const {
  return now_;
}
inline void Emc_Motion_Set_Dout::set_now(bool value) {
  set_has_now();
  now_ = value;
}

// -------------------------------------------------------------------

// Emc_Motion_Set_Aout

// required uint32 index = 10;
inline bool Emc_Motion_Set_Aout::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Set_Aout::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Set_Aout::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Motion_Set_Aout::index() const {
  return index_;
}
inline void Emc_Motion_Set_Aout::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required double start = 20;
inline bool Emc_Motion_Set_Aout::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Motion_Set_Aout::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Motion_Set_Aout::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double Emc_Motion_Set_Aout::start() const {
  return start_;
}
inline void Emc_Motion_Set_Aout::set_start(double value) {
  set_has_start();
  start_ = value;
}

// required double end = 30;
inline bool Emc_Motion_Set_Aout::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Motion_Set_Aout::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Motion_Set_Aout::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline double Emc_Motion_Set_Aout::end() const {
  return end_;
}
inline void Emc_Motion_Set_Aout::set_end(double value) {
  set_has_end();
  end_ = value;
}

// required bool now = 40;
inline bool Emc_Motion_Set_Aout::has_now() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_now() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Motion_Set_Aout::clear_has_now() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Motion_Set_Aout::clear_now() {
  now_ = false;
  clear_has_now();
}
inline bool Emc_Motion_Set_Aout::now() const {
  return now_;
}
inline void Emc_Motion_Set_Aout::set_now(bool value) {
  set_has_now();
  now_ = value;
}

// -------------------------------------------------------------------

// Emc_Aux_Input_Wait

// required uint32 index = 10;
inline bool Emc_Aux_Input_Wait::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Aux_Input_Wait::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Aux_Input_Wait::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Aux_Input_Wait::index() const {
  return index_;
}
inline void Emc_Aux_Input_Wait::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required .pb.InputType input_type = 20;
inline bool Emc_Aux_Input_Wait::has_input_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_input_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Aux_Input_Wait::clear_has_input_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Aux_Input_Wait::clear_input_type() {
  input_type_ = 0;
  clear_has_input_type();
}
inline ::pb::InputType Emc_Aux_Input_Wait::input_type() const {
  return static_cast< ::pb::InputType >(input_type_);
}
inline void Emc_Aux_Input_Wait::set_input_type(::pb::InputType value) {
  assert(::pb::InputType_IsValid(value));
  set_has_input_type();
  input_type_ = value;
}

// required .pb.WaitType wait_type = 30;
inline bool Emc_Aux_Input_Wait::has_wait_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_wait_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Aux_Input_Wait::clear_has_wait_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Aux_Input_Wait::clear_wait_type() {
  wait_type_ = 0;
  clear_has_wait_type();
}
inline ::pb::WaitType Emc_Aux_Input_Wait::wait_type() const {
  return static_cast< ::pb::WaitType >(wait_type_);
}
inline void Emc_Aux_Input_Wait::set_wait_type(::pb::WaitType value) {
  assert(::pb::WaitType_IsValid(value));
  set_has_wait_type();
  wait_type_ = value;
}

// required double timeout = 40;
inline bool Emc_Aux_Input_Wait::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Aux_Input_Wait::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Aux_Input_Wait::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline double Emc_Aux_Input_Wait::timeout() const {
  return timeout_;
}
inline void Emc_Aux_Input_Wait::set_timeout(double value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Emc_Exec_Plugin_Ca1l

// required bytes call = 20;
inline bool Emc_Exec_Plugin_Ca1l::has_call() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Exec_Plugin_Ca1l::set_has_call() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Exec_Plugin_Ca1l::clear_has_call() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Exec_Plugin_Ca1l::clear_call() {
  if (call_ != &::google::protobuf::internal::GetEmptyString()) {
    call_->clear();
  }
  clear_has_call();
}
inline const ::std::string& Emc_Exec_Plugin_Ca1l::call() const {
  return *call_;
}
inline void Emc_Exec_Plugin_Ca1l::set_call(const ::std::string& value) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(value);
}
inline void Emc_Exec_Plugin_Ca1l::set_call(const char* value) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(value);
}
inline void Emc_Exec_Plugin_Ca1l::set_call(const void* value, size_t size) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Emc_Exec_Plugin_Ca1l::mutable_call() {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  return call_;
}
inline ::std::string* Emc_Exec_Plugin_Ca1l::release_call() {
  clear_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = call_;
    call_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Emc_Exec_Plugin_Ca1l::set_allocated_call(::std::string* call) {
  if (call_ != &::google::protobuf::internal::GetEmptyString()) {
    delete call_;
  }
  if (call) {
    set_has_call();
    call_ = call;
  } else {
    clear_has_call();
    call_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Emc_Io_Plugin_Call

// required bytes call = 20;
inline bool Emc_Io_Plugin_Call::has_call() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Io_Plugin_Call::set_has_call() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Io_Plugin_Call::clear_has_call() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Io_Plugin_Call::clear_call() {
  if (call_ != &::google::protobuf::internal::GetEmptyString()) {
    call_->clear();
  }
  clear_has_call();
}
inline const ::std::string& Emc_Io_Plugin_Call::call() const {
  return *call_;
}
inline void Emc_Io_Plugin_Call::set_call(const ::std::string& value) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(value);
}
inline void Emc_Io_Plugin_Call::set_call(const char* value) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(value);
}
inline void Emc_Io_Plugin_Call::set_call(const void* value, size_t size) {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  call_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Emc_Io_Plugin_Call::mutable_call() {
  set_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    call_ = new ::std::string;
  }
  return call_;
}
inline ::std::string* Emc_Io_Plugin_Call::release_call() {
  clear_has_call();
  if (call_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = call_;
    call_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Emc_Io_Plugin_Call::set_allocated_call(::std::string* call) {
  if (call_ != &::google::protobuf::internal::GetEmptyString()) {
    delete call_;
  }
  if (call) {
    set_has_call();
    call_ = call;
  } else {
    clear_has_call();
    call_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_canon_2eproto__INCLUDED
