/****************************************************************************
**
** This file was generated by a code generator based on imatix/gsl
** Any changes in this file will be lost.
**
****************************************************************************/
#ifndef REMOTE_FILE_FILE_BASE_H
#define REMOTE_FILE_FILE_BASE_H
#include <QObject>
#include <QSet>
#include <QDebug>
#include <QQmlParserStatus>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include "../common/rpcclient.h"

namespace machinetalk { namespace remotefile {

class FileBase
    : public QObject
    , public QQmlParserStatus
{
    Q_OBJECT
    Q_INTERFACES(QQmlParserStatus)
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
    Q_PROPERTY(QString file2Uri READ file2Uri WRITE setFile2Uri NOTIFY file2UriChanged)
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State connectionState READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(int file2HeartbeatInterval READ file2HeartbeatInterval WRITE setFile2HeartbeatInterval NOTIFY file2HeartbeatIntervalChanged)

public:
    explicit FileBase(QObject *parent = nullptr);
    ~FileBase();

    enum class State {
        Down = 0,
        Trying = 1,
        Up = 2,
        Get = 3,
        Put = 4,
        Ls = 5,
        Mkdir = 6,
        Delete = 7,
    };
    Q_ENUM(State)

    void classBegin() {}
    /** componentComplete is executed when the QML component is fully loaded */
    void componentComplete()
    {
        m_componentCompleted = true;

        if (m_ready == true)    // the component was set to ready before it was completed
        {
            start();
        }
    }

    QString file2Uri() const
    {
        return m_file2Channel->socketUri();
    }

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }

    int file2HeartbeatInterval() const
    {
        return m_file2Channel->heartbeatInterval();
    }

    bool ready() const
    {
        return m_ready;
    }

public slots:

    void setFile2Uri(const QString &uri)
    {
        m_file2Channel->setSocketUri(uri);
    }

    void setDebugName(const QString &debugName)
    {
        if (m_debugName == debugName) {
            return;
        }

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }

    void setFile2HeartbeatInterval(int interval)
    {
        m_file2Channel->setHeartbeatInterval(interval);
    }

    void setReady(bool ready)
    {
        if (m_ready == ready) {
            return;
        }

        m_ready = ready;
        emit readyChanged(ready);

        if (m_componentCompleted == false)
        {
            return;
        }

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }


    void sendFile2Message(ContainerType type, Container &tx);
    void sendFileGet(Container &tx);
    void sendFilePut(Container &tx);
    void sendFileLs(Container &tx);
    void sendFileMkdir(Container &tx);
    void sendFileDelete(Container &tx);

protected:
    void start(); // start trigger
    void stop(); // stop trigger

private:
    bool m_componentCompleted;
    bool m_ready;
    QString m_debugName;

    common::RpcClient *m_file2Channel;

    State         m_state;
    State         m_previousState;
    QString       m_errorString;
    // more efficient to reuse a protobuf Messages
    Container m_file2Rx;
    Container m_file2Tx;

private slots:

    void startFile2Channel();
    void stopFile2Channel();
    void file2ChannelStateChanged(common::RpcClient::State state);
    void processFile2ChannelMessage(const Container &rx);

    void fsmDown();
    void fsmDownEntry();
    void fsmDownConnectEvent();
    void fsmTrying();
    void fsmTryingFile2UpEvent();
    void fsmTryingDisconnectEvent();
    void fsmUp();
    void fsmUpEntry();
    void fsmUpFile2TryingEvent();
    void fsmUpDisconnectEvent();
    void fsmUpGetMsgSentEvent();
    void fsmUpPutMsgSentEvent();
    void fsmUpLsMsgSentEvent();
    void fsmUpMkdirMsgSentEvent();
    void fsmUpDeleteMsgSentEvent();
    void fsmGet();
    void fsmGetGetSuccessfulEvent();
    void fsmGetGetFailedEvent();
    void fsmGetDisconnectEvent();
    void fsmPut();
    void fsmPutPutSuccessfulEvent();
    void fsmPutPutFailedEvent();
    void fsmPutDisconnectEvent();
    void fsmLs();
    void fsmLsLsSuccessfulEvent();
    void fsmLsLsFailedEvent();
    void fsmLsDisconnectEvent();
    void fsmMkdir();
    void fsmMkdirMkdirSuccessfulEvent();
    void fsmMkdirMkdirFailedEvent();
    void fsmMkdirDisconnectEvent();
    void fsmDelete();
    void fsmDeleteDeleteSuccessfulEvent();
    void fsmDeleteDeleteFailedEvent();
    void fsmDeleteDisconnectEvent();

    virtual void handleFileListingMessage(const Container &rx) = 0;
    virtual void handleFileDataMessage(const Container &rx) = 0;
    virtual void setConnected() = 0;
    virtual void clearConnected() = 0;
    virtual void getCmdStarted() = 0;
    virtual void getCmdSucceded() = 0;
    virtual void getCmdFailed() = 0;
    virtual void putCmdStarted() = 0;
    virtual void putCmdSucceded() = 0;
    virtual void putCmdFailed() = 0;
    virtual void lsCmdStarted() = 0;
    virtual void lsCmdSucceded() = 0;
    virtual void lsCmdFailed() = 0;
    virtual void mkdirCmdStarted() = 0;
    virtual void mkdirCmdSucceded() = 0;
    virtual void mkdirCmdFailed() = 0;
    virtual void deleteCmdStarted() = 0;
    virtual void deleteCmdSucceded() = 0;
    virtual void deleteCmdFailed() = 0;

signals:
    void file2UriChanged(const QString &uri);
    void file2MessageReceived(const Container &rx);
    void debugNameChanged(const QString &debugName);
    void stateChanged(FileBase::State state);
    void errorStringChanged(const QString &errorString);
    void file2HeartbeatIntervalChanged(int interval);
    void readyChanged(bool ready);
    // fsm
    void fsmDownEntered(QPrivateSignal);
    void fsmDownExited(QPrivateSignal);
    void fsmDownConnect(QPrivateSignal);
    void fsmTryingEntered(QPrivateSignal);
    void fsmTryingExited(QPrivateSignal);
    void fsmTryingFile2Up(QPrivateSignal);
    void fsmTryingDisconnect(QPrivateSignal);
    void fsmUpEntered(QPrivateSignal);
    void fsmUpExited(QPrivateSignal);
    void fsmUpFile2Trying(QPrivateSignal);
    void fsmUpDisconnect(QPrivateSignal);
    void fsmUpGetMsgSent(QPrivateSignal);
    void fsmUpPutMsgSent(QPrivateSignal);
    void fsmUpLsMsgSent(QPrivateSignal);
    void fsmUpMkdirMsgSent(QPrivateSignal);
    void fsmUpDeleteMsgSent(QPrivateSignal);
    void fsmGetEntered(QPrivateSignal);
    void fsmGetExited(QPrivateSignal);
    void fsmGetGetSuccessful(QPrivateSignal);
    void fsmGetGetFailed(QPrivateSignal);
    void fsmGetDisconnect(QPrivateSignal);
    void fsmPutEntered(QPrivateSignal);
    void fsmPutExited(QPrivateSignal);
    void fsmPutPutSuccessful(QPrivateSignal);
    void fsmPutPutFailed(QPrivateSignal);
    void fsmPutDisconnect(QPrivateSignal);
    void fsmLsEntered(QPrivateSignal);
    void fsmLsExited(QPrivateSignal);
    void fsmLsLsSuccessful(QPrivateSignal);
    void fsmLsLsFailed(QPrivateSignal);
    void fsmLsDisconnect(QPrivateSignal);
    void fsmMkdirEntered(QPrivateSignal);
    void fsmMkdirExited(QPrivateSignal);
    void fsmMkdirMkdirSuccessful(QPrivateSignal);
    void fsmMkdirMkdirFailed(QPrivateSignal);
    void fsmMkdirDisconnect(QPrivateSignal);
    void fsmDeleteEntered(QPrivateSignal);
    void fsmDeleteExited(QPrivateSignal);
    void fsmDeleteDeleteSuccessful(QPrivateSignal);
    void fsmDeleteDeleteFailed(QPrivateSignal);
    void fsmDeleteDisconnect(QPrivateSignal);
};

} } // namespace machinetalk::remotefile
#endif // REMOTE_FILE_FILE_BASE_H
